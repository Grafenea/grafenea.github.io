<!DOCTYPE html>
<html>
<head>

<!--
passwdhash

Copyright (C) 2011 Felix Kästner, passwdhash @ f p u n k t k . de

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, see http://www.gnu.org/licenses/.
-->

<meta charset="UTF-8">
<meta name="referrer" content="no-referrer">
<title>passwdhash</title>
<link rel="icon" href="favicon-ph.png" type="image/png">

<script type="text/javascript">
// BEGIN SHA 256
// Chris Veness LGPL http://www.movable-type.co.uk/scripts/sha256.html

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */
/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */
/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Sha256 = {};  // Sha256 namespace

/**
 * Generates SHA-256 hash of string
 *
 * @param {String} msg                String to be hashed
 * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash
 * @returns {String}                  Hash of msg as hex character string
 */
Sha256.hash = function(msg, utf8encode) {
    utf8encode =  (typeof utf8encode == 'undefined') ? true : utf8encode;
    
    // convert string to UTF-8, as SHA only deals with byte-streams
    if (utf8encode) msg = Utf8.encode(msg);
    
    // constants [§4.2.2]
    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
             0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
             0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
             0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
             0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
             0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
             0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
             0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
    // initial hash value [§5.3.1]
    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];

    // PREPROCESSING 
 
    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]

    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]
    var l = msg.length/4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length
    var N = Math.ceil(l/16);   // number of 16-integer-blocks required to hold 'l' ints
    var M = new Array(N);

    for (var i=0; i<N; i++) {
        M[i] = new Array(16);
        for (var j=0; j<16; j++) {  // encode 4 chars per integer, big-endian encoding
            M[i][j] = (msg.charCodeAt(i*64+j*4)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16) | 
                      (msg.charCodeAt(i*64+j*4+2)<<8) | (msg.charCodeAt(i*64+j*4+3));
        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0
    }
    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]
    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts
    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
    M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14])
    M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;


    // HASH COMPUTATION [§6.1.2]

    var W = new Array(64); var a, b, c, d, e, f, g, h;
    for (var i=0; i<N; i++) {

        // 1 - prepare message schedule 'W'
        for (var t=0;  t<16; t++) W[t] = M[i][t];
        for (var t=16; t<64; t++) W[t] = (Sha256.sigma1(W[t-2]) + W[t-7] + Sha256.sigma0(W[t-15]) + W[t-16]) & 0xffffffff;

        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value
        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];

        // 3 - main loop (note 'addition modulo 2^32')
        for (var t=0; t<64; t++) {
            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];
            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);
            h = g;
            g = f;
            f = e;
            e = (d + T1) & 0xffffffff;
            d = c;
            c = b;
            b = a;
            a = (T1 + T2) & 0xffffffff;
        }
         // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')
        H[0] = (H[0]+a) & 0xffffffff;
        H[1] = (H[1]+b) & 0xffffffff; 
        H[2] = (H[2]+c) & 0xffffffff; 
        H[3] = (H[3]+d) & 0xffffffff; 
        H[4] = (H[4]+e) & 0xffffffff;
        H[5] = (H[5]+f) & 0xffffffff;
        H[6] = (H[6]+g) & 0xffffffff; 
        H[7] = (H[7]+h) & 0xffffffff; 
    }

    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + 
           Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);
}

Sha256.ROTR = function(n, x) { return (x >>> n) | (x << (32-n)); }
Sha256.Sigma0 = function(x) { return Sha256.ROTR(2,  x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }
Sha256.Sigma1 = function(x) { return Sha256.ROTR(6,  x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }
Sha256.sigma0 = function(x) { return Sha256.ROTR(7,  x) ^ Sha256.ROTR(18, x) ^ (x>>>3);  }
Sha256.sigma1 = function(x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x>>>10); }
Sha256.Ch = function(x, y, z)  { return (x & y) ^ (~x & z); }
Sha256.Maj = function(x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }

//
// hexadecimal representation of a number 
//   (note toString(16) is implementation-dependant, and  
//   in IE returns signed numbers when used on full words)
//
Sha256.toHexStr = function(n) {
  var s="", v;
  for (var i=7; i>=0; i--) { v = (n>>>(i*4)) & 0xf; s += v.toString(16); }
  return s;
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */
/*              single-byte character encoding (c) Chris Veness 2002-2010                         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Utf8 = {};  // Utf8 namespace

/**
 * Encode multi-byte Unicode string into utf-8 multiple single-byte characters 
 * (BMP / basic multilingual plane only)
 *
 * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars
 *
 * @param {String} strUni Unicode string to be encoded as UTF-8
 * @returns {String} encoded string
 */
Utf8.encode = function(strUni) {
  // use regular expressions & String.replace callback function for better efficiency 
  // than procedural approaches
  var strUtf = strUni.replace(
      /[\u0080-\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0);
        return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
    );
  strUtf = strUtf.replace(
      /[\u0800-\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0); 
        return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
    );
  return strUtf;
}

/**
 * Decode utf-8 encoded string back into multi-byte Unicode characters
 *
 * @param {String} strUtf UTF-8 string to be decoded back to Unicode
 * @returns {String} decoded string
 */
Utf8.decode = function(strUtf) {
  // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!
  var strUni = strUtf.replace(
      /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = ((c.charCodeAt(0)&0x0f)<<12) | ((c.charCodeAt(1)&0x3f)<<6) | ( c.charCodeAt(2)&0x3f); 
        return String.fromCharCode(cc); }
    );
  strUni = strUni.replace(
      /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
        return String.fromCharCode(cc); }
    );
  return strUni;
}

// END SHA 256

// BEGIN functions and constants

/*
changeing the following values and functions will change the way how passwords will be created or saved. so don't change this (when you already used it) or at least make a backup of the unchanged values. otherwise your passwords will be lost!
*/
const GLOBALSALT = "yZpenh5cHo7yVkXeEOk3mGzCQjpmr8BF"; // don't change
const DERIVATION_CYCLES = 6000; // don't change

const CHARS_LOWER = "abcdefghijklmnopqrstuvwxyz"; // don't change
const CHARS_UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // don't change
const CHARS_NUMBER = "0123456789"; // don't change
const CHARS_SPECIAL = ",.;:-_#+*!?§$%&~@µ=|()[]{}<>"; // /\^° // don't change
const BASE64_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"; // don't change

function baseconvert(str, frombase, tobase) {
    return parseInt(str, frombase).toString(tobase);
}

/*
    take base16 input (like sha256 hash) and convert it to a password
    rules:
        - first character is either lower- or uppercase letter
        - next three characters are a number, a special char and a upper- or lowercase letter, depending on the first character
        - remaining characters can be of any kind
*/
function base16_to_passwd(b16string, special_chars) { // don't change
    if ( b16string.length < 10 )
        return "ERROR: b16string " + b16string + " is too short";
    
    var local_CHARS_SPECIAL = CHARS_SPECIAL;
    if ( special_chars == "no_special_chars" )
        local_CHARS_SPECIAL = CHARS_LOWER + CHARS_UPPER + CHARS_NUMBER;
    
    var first_two_b2 = "00" + baseconvert(b16string.substr(0, 2), 16, 2); // add 00 in case it would be just 0 or 1
    var lo_up = parseInt(first_two_b2.charAt(first_two_b2.length - 1), 2); // last bit, converted to integer
    var order_three = parseInt(first_two_b2.substr(0, first_two_b2.length - 2), 2) % 6; // remaining bits, converted to integer, modulo 6, because there will be 6 cases in the lookup table
    
    var arr_1_lo_up = [CHARS_LOWER.charAt(parseInt(b16string.substr(2, 2), 16) % CHARS_LOWER.length), CHARS_UPPER.charAt(parseInt(b16string.substr(4, 2), 16) % CHARS_UPPER.length)];
    var first_lo_up = arr_1_lo_up[lo_up];
    var two_to_four_lo_up = arr_1_lo_up[(lo_up + 1) % 2];
    var two_to_four_number = CHARS_NUMBER.charAt(parseInt(b16string.substr(6, 2), 16) % CHARS_NUMBER.length);
    var two_to_four_special = local_CHARS_SPECIAL.charAt(parseInt(b16string.substr(8, 2), 16) % local_CHARS_SPECIAL.length);
    
    // lookup table for order of chars 2 to 4
    var arr_two_to_four = [two_to_four_lo_up + two_to_four_number + two_to_four_special, two_to_four_lo_up + two_to_four_special + two_to_four_number, two_to_four_number + two_to_four_lo_up + two_to_four_special, two_to_four_number + two_to_four_special + two_to_four_lo_up, two_to_four_special + two_to_four_lo_up + two_to_four_number, two_to_four_special + two_to_four_number + two_to_four_lo_up];
    
    var first_four = first_lo_up + arr_two_to_four[order_three];
    
    var b16string_idx = 10;

    // take a few chars from b16string, first is an index, next two are translated into a special char
    var arr_special_idx = new Array();
    var arr_special_chars = new Array();
    for ( var i = 1; i <= 6; i++ ) {
        if ( b16string_idx >= b16string.length ) break;
        arr_special_idx.push(parseInt(b16string.substr(b16string_idx, 1), 16));
        arr_special_chars.push(local_CHARS_SPECIAL.charAt(parseInt(b16string.substr(b16string_idx + 1, 2), 16) % local_CHARS_SPECIAL.length));
        b16string_idx += 3;
    }
    
    // build up passwd, translate three chars from b16string into two base64 chars
    var passwd = "";
    while ( b16string_idx < b16string.length - 4 ) {
        b64_idx = parseInt(b16string.substr(b16string_idx, 3), 16);
        passwd += BASE64_CHARS.charAt(Math.floor(b64_idx / 64)) + BASE64_CHARS.charAt(b64_idx % 64);
        b16string_idx += 3;
    }
    
    // insert the special chars from above in passwd, indices add up
    var idx = -1;
    for ( var i = 0; i < arr_special_idx.length; i++ ) {
        idx = ( arr_special_idx[i] + idx + 1 ) % passwd.length;
        passwd = passwd.substring(0, idx) + arr_special_chars[i] + passwd.substring(idx);
    }
    
    // add the first four chars from above to passwd
    passwd = first_four + passwd;
    
    return passwd; // + " - " + passwd.length + " - " + arr_special_idx.join(",") + " - " + arr_special_chars.join(" ") + " - " + order_three;
}

// hash the string multiple times. this takes about a second and slows down brute force attacs (trying all sha256 hashes takes way too long, hashing all short strings also takes longer than just trying all short strings). anyway, it will be much faster with a compiled algorithm.
function slow_passwd_derivation(passwd) { // don't change
    for ( var i = 1; i <= DERIVATION_CYCLES; i++ ) {
        passwd = Sha256.hash(passwd);
    }
    return passwd;
}

// create a password from refplain and masterpasswd
function make_passwdhash(ctr, length) { // don't change
    ctr = (typeof ctr == 'undefined') ? 0 : ctr;
    length = ( length == "val" ) ? document.getElementById("ph_length").value : "full";
    var masterpasswd = document.getElementById("masterpasswd").value;
    masterpasswd = slow_passwd_derivation(masterpasswd);
    var refplain = document.getElementById("ph_refplain").value;
    var refpasswdsha256 = Sha256.hash(GLOBALSALT + ctr + masterpasswd + refplain);
    var no_special = "false";
    if ( document.getElementById("ph_no_special_chars").checked )
        no_special = "no_special_chars";
    var refpasswd = base16_to_passwd(refpasswdsha256, no_special);
    if ( length <= refpasswd.length ) // this also tests wheather length is a valid integer
        refpasswd = refpasswd.substr(0, length);
    document.getElementById("ph_refpasswd").value = refpasswd;
}

</script>

<style type="text/css">
body {
    color: #000000;
    background-color: #8CBAEC;
    text-align: left;
    margin: 3ex auto 70ex;
    padding: 1.2ex;
    max-width: 75ex;
    font-size: 12pt;
}
input {
    font: 11pt monospace;
}
input.long {
    width: 100%;
}
div {
    margin: 0ex 0ex 2ex;
}
td {
    text-align: center;
    height: 4ex;
}
</style>

</head>

<body>

<h1><a href="">passwdhash</a></h1>

<noscript>
<span style="color: red; font-size: 200%; font-weight: bold;">please enable javascript</span>
</noscript>

<div style="color: #bb4488; font-weight: bold;">
Use this at your own risk! Keep a backup of this site! Don't blame me for any loss of data!
</div>

<div>
<label>masterpassword: <input id="masterpasswd" style="width: 50%;" type="password"></label>
<input type="button" value="clear" onclick='document.getElementById("masterpasswd").value = "";'>
</div>

<div>
<label>URL / reference: <input id="ph_refplain" class="long" type="text"></label><br>
<label><input type="checkbox" id="ph_no_special_chars" checked> fewer special chars</label>
</div>

<div>
<table style="width: 100%;">
<tr>
<td>all</td>
<td><input type="button" value="0" onclick="make_passwdhash(0);"></td>
<td><input type="button" value="1" onclick="make_passwdhash(1);"></td>
<td><input type="button" value="2" onclick="make_passwdhash(2);"></td>
<td><input type="button" value="3" onclick="make_passwdhash(3);"></td>
<td><input type="button" value="4" onclick="make_passwdhash(4);"></td>
<td><input type="button" value="5" onclick="make_passwdhash(5);"></td>
<td><input type="button" value="6" onclick="make_passwdhash(6);"></td>
<td><input type="button" value="7" onclick="make_passwdhash(7);"></td>
<td><input type="button" value="8" onclick="make_passwdhash(8);"></td>
<td><input type="button" value="9" onclick="make_passwdhash(9);"></td>
</tr>
<td><input id="ph_length" size="3" type="text" value="20" style="text-align: center;"></td>
<td><input type="button" value="0" onclick="make_passwdhash(0,'val');"></td>
<td><input type="button" value="1" onclick="make_passwdhash(1,'val');"></td>
<td><input type="button" value="2" onclick="make_passwdhash(2,'val');"></td>
<td><input type="button" value="3" onclick="make_passwdhash(3,'val');"></td>
<td><input type="button" value="4" onclick="make_passwdhash(4,'val');"></td>
<td><input type="button" value="5" onclick="make_passwdhash(5,'val');"></td>
<td><input type="button" value="6" onclick="make_passwdhash(6,'val');"></td>
<td><input type="button" value="7" onclick="make_passwdhash(7,'val');"></td>
<td><input type="button" value="8" onclick="make_passwdhash(8,'val');"></td>
<td><input type="button" value="9" onclick="make_passwdhash(9,'val');"></td>
</tr>
</table>
</div>

<div>
<label>generated password: <input id="ph_refpasswd" class="long" type="text"></label>
<input type="button" value="clear" onclick='document.getElementById("ph_refplain").value = ""; document.getElementById("ph_refpasswd").value = "";'>
</div>

</body>
</html>
